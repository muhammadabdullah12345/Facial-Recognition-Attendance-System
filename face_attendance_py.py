# -*- coding: utf-8 -*-
"""face_attendance.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NGI_y7qzlfvzfWehrJCmkS1b_23mbY6v
"""

#!/usr/bin/env python3
"""
CPU-Optimized Face Attendance System for Jetson Orin
Optimized for CPU-only execution without CUDA
"""

import os
import cv2
import numpy as np
import pandas as pd
import time
import warnings
from datetime import datetime
from deepface import DeepFace
import logging
import zipfile
import shutil

# Suppress warnings
warnings.filterwarnings('ignore')
logging.getLogger('deepface').setLevel(logging.WARNING)

# ============================================
# CPU OPTIMIZATION CONFIGURATION
# ============================================
class CPUModeConfig:
    PROCESSING_WIDTH = 640
    PROCESSING_HEIGHT = 480
    SKIP_FRAMES = 2
    DETECTION_BACKEND = 'retinaface'
    MIN_FACE_SIZE = 40
    EMBEDDING_MODEL = 'Facenet512'
    FACE_RESIZE_DIM = 160
    ENABLE_EMBEDDING_CACHE = True
    ATTENDANCE_FILE = 'attendance.csv'
    COOLDOWN_SECONDS = 30
    CONFIDENCE_THRESHOLD = 0.65
    SHOW_FPS = True

# ============================================
# GLOBAL CACHE
# ============================================
class EmbeddingCache:
    def __init__(self):
        self.cache = {}
        self.last_detection = {}

    def get(self, filename):
        return self.cache.get(filename)

    def set(self, filename, embedding):
        self.cache[filename] = embedding

    def can_mark_attendance(self, name):
        current_time = time.time()
        last_time = self.last_detection.get(name, 0)
        return (current_time - last_time) > CPUModeConfig.COOLDOWN_SECONDS

    def update_last_detection(self, name):
        self.last_detection[name] = time.time()

embedding_cache = EmbeddingCache()

# ============================================
# DATABASE MANAGEMENT
# ============================================
def setup_dataset(zip_path='face_dataset.zip', extract_to='known_images'):
    """Extract dataset and setup folder structure"""
    print(f"[INFO] Setting up dataset from {zip_path}...")

    # Remove old folder if exists
    if os.path.exists(extract_to):
        print(f"[INFO] Removing old {extract_to} folder...")
        shutil.rmtree(extract_to)

    # Extract zip file
    if os.path.exists(zip_path):
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_to)
            print(f"[SUCCESS] Extracted dataset to {extract_to}/")

            # Count extracted files
            all_files = []
            for root, dirs, files in os.walk(extract_to):
                for file in files:
                    if file.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp', '.pgm')):
                        all_files.append(os.path.join(root, file))

            print(f"[INFO] Found {len(all_files)} image files")
            return True

        except Exception as e:
            print(f"[ERROR] Failed to extract {zip_path}: {str(e)}")
            return False
    else:
        print(f"[WARNING] {zip_path} not found. Creating empty {extract_to}/ folder")
        os.makedirs(extract_to, exist_ok=True)
        return True

def build_face_database(known_images_path='known_images'):
    """Build face database from images"""
    face_database = {}

    if not os.path.exists(known_images_path):
        print(f"[WARNING] {known_images_path} not found. Creating empty folder.")
        os.makedirs(known_images_path, exist_ok=True)
        return face_database

    # Find all image files (including in subfolders)
    image_files = []
    for root, dirs, files in os.walk(known_images_path):
        for file in files:
            if file.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp', '.pgm')):
                image_files.append(os.path.join(root, file))

    if not image_files:
        print(f"[INFO] No images found. System will run in detection-only mode.")
        return face_database

    print(f"[INFO] Building face database from {len(image_files)} images...")

    for img_path in image_files:
        try:
            # Get person name from filename (without extension)
            name = os.path.splitext(os.path.basename(img_path))[0]

            # Cache check
            if CPUModeConfig.ENABLE_EMBEDDING_CACHE:
                cached_embedding = embedding_cache.get(img_path)
                if cached_embedding is not None:
                    face_database[name] = cached_embedding
                    print(f"  [CACHE] {name}")
                    continue

            # Generate embedding
            embedding_obj = DeepFace.represent(
                img_path=img_path,
                model_name=CPUModeConfig.EMBEDDING_MODEL,
                detector_backend=CPUModeConfig.DETECTION_BACKEND,
                enforce_detection=False
            )

            if embedding_obj:
                embedding = embedding_obj[0]['embedding']
                face_database[name] = embedding

                if CPUModeConfig.ENABLE_EMBEDDING_CACHE:
                    embedding_cache.set(img_path, embedding)

                print(f"  [OK] {name}")
            else:
                print(f"  [SKIP] No face in {os.path.basename(img_path)}")

        except Exception as e:
            print(f"  [ERROR] {os.path.basename(img_path)}: {str(e)}")

    print(f"[SUCCESS] Database built with {len(face_database)} faces")
    return face_database

# ============================================
# ATTENDANCE LOGGING
# ============================================
def mark_attendance(name, confidence):
    """Mark attendance in CSV"""
    try:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        if os.path.exists(CPUModeConfig.ATTENDANCE_FILE):
            df = pd.read_csv(CPUModeConfig.ATTENDANCE_FILE)
        else:
            df = pd.DataFrame(columns=['Name', 'Timestamp', 'Confidence'])

        new_entry = pd.DataFrame({
            'Name': [name],
            'Timestamp': [timestamp],
            'Confidence': [f"{confidence:.2f}"]
        })

        df = pd.concat([df, new_entry], ignore_index=True)
        df.to_csv(CPUModeConfig.ATTENDANCE_FILE, index=False)

        print(f"âœ“ {name} at {timestamp} ({confidence:.2f})")
        return True

    except Exception as e:
        print(f"[ERROR] Attendance failed: {str(e)}")
        return False

# ============================================
# FACE RECOGNITION
# ============================================
def recognize_face(face_img, face_database):
    """Recognize face from database"""
    if not face_database:
        return "Unknown", 0.0

    try:
        # Save temp file for DeepFace
        temp_path = "temp_face.jpg"
        cv2.imwrite(temp_path, face_img)

        # Generate embedding
        embedding_obj = DeepFace.represent(
            img_path=temp_path,
            model_name=CPUModeConfig.EMBEDDING_MODEL,
            detector_backend=CPUModeConfig.DETECTION_BACKEND,
            enforce_detection=False
        )

        if os.path.exists(temp_path):
            os.remove(temp_path)

        if not embedding_obj:
            return "Unknown", 0.0

        detected_embedding = embedding_obj[0]['embedding']
        best_match = "Unknown"
        best_distance = float('inf')

        # Compare with database
        for name, db_embedding in face_database.items():
            db_embedding = np.array(db_embedding)
            detected_embedding_array = np.array(detected_embedding)

            db_norm = db_embedding / (np.linalg.norm(db_embedding) + 1e-10)
            detected_norm = detected_embedding_array / (np.linalg.norm(detected_embedding_array) + 1e-10)

            distance = 1 - np.dot(db_norm, detected_norm)

            if distance < best_distance:
                best_distance = distance
                best_match = name

        confidence = max(0, 1 - best_distance)

        if confidence < CPUModeConfig.CONFIDENCE_THRESHOLD:
            return "Unknown", confidence

        return best_match, confidence

    except Exception as e:
        return "Unknown", 0.0

# ============================================
# MAIN FUNCTION
# ============================================
def main():
    print("=" * 60)
    print("FACE ATTENDANCE SYSTEM - JETSON ORIN")
    print("=" * 60)

    # Step 1: Setup dataset
    setup_dataset()

    # Step 2: Build database
    face_database = build_face_database()

    # Step 3: Initialize camera
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("[ERROR] Camera not accessible")
        return

    cap.set(cv2.CAP_PROP_FRAME_WIDTH, CPUModeConfig.PROCESSING_WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CPUModeConfig.PROCESSING_HEIGHT)

    print(f"\n[INFO] Camera: {CPUModeConfig.PROCESSING_WIDTH}x{CPUModeConfig.PROCESSING_HEIGHT}")
    print(f"[INFO] Faces in DB: {len(face_database)}")
    print(f"[INFO] Press 'q' to quit")
    print("=" * 60)

    frame_count = 0
    fps = 0
    fps_time = time.time()
    fps_frames = 0

    try:
        while True:
            ret, frame = cap.read()
            if not ret:
                break

            # Skip frames optimization
            if CPUModeConfig.SKIP_FRAMES > 0 and frame_count % (CPUModeConfig.SKIP_FRAMES + 1) != 0:
                frame_count += 1
                continue

            display_frame = frame.copy()

            try:
                # Detect faces
                faces = DeepFace.extract_faces(
                    img_path=frame,
                    detector_backend=CPUModeConfig.DETECTION_BACKEND,
                    enforce_detection=False,
                    align=False
                )

                for face_info in faces:
                    if 'facial_area' in face_info:
                        x, y, w, h = face_info['facial_area'].values()

                        if w < CPUModeConfig.MIN_FACE_SIZE or h < CPUModeConfig.MIN_FACE_SIZE:
                            continue

                        face_region = frame[y:y+h, x:x+w]

                        if face_region.size > 0:
                            face_region = cv2.resize(face_region, (CPUModeConfig.FACE_RESIZE_DIM, CPUModeConfig.FACE_RESIZE_DIM))
                            name, confidence = recognize_face(face_region, face_database)

                            # Draw box
                            color = (0, 255, 0) if name != "Unknown" else (0, 0, 255)
                            cv2.rectangle(display_frame, (x, y), (x+w, y+h), color, 2)

                            # Draw label
                            label = f"{name} ({confidence:.2f})"
                            cv2.putText(display_frame, label, (x, y-10),
                                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

                            # Mark attendance
                            if name != "Unknown" and embedding_cache.can_mark_attendance(name):
                                if mark_attendance(name, confidence):
                                    embedding_cache.update_last_detection(name)

            except:
                pass  # Continue if face detection fails

            # FPS counter
            fps_frames += 1
            if time.time() - fps_time >= 1.0:
                fps = fps_frames
                fps_frames = 0
                fps_time = time.time()

            # Display info
            cv2.putText(display_frame, f"FPS: {fps}", (10, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
            cv2.putText(display_frame, f"Faces in DB: {len(face_database)}", (10, 60),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)

            # Show frame
            cv2.imshow('Face Attendance System', display_frame)

            # Key press
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                break

            frame_count += 1

    except KeyboardInterrupt:
        print("\n[INFO] Stopped by user")

    finally:
        cap.release()
        cv2.destroyAllWindows()
        print(f"\n[SUCCESS] Attendance saved to: {CPUModeConfig.ATTENDANCE_FILE}")
        print("[INFO] System stopped")

# ============================================
# ENTRY POINT
# ============================================
if __name__ == "__main__":
    print("[SYSTEM START]")

    # Check dependencies
    try:
        import cv2, torch, deepface, pandas, numpy
        print(f"[OK] OpenCV: {cv2.__version__}")
        print(f"[OK] PyTorch: {torch.__version__}")
        print(f"[OK] DeepFace: {deepface.__version__}")
    except ImportError as e:
        print(f"[ERROR] Missing dependency: {str(e)}")
        print("[FIX] Run: pip install torch opencv-python deepface pandas numpy")
        exit(1)

    # Check camera
    test_cap = cv2.VideoCapture(0)
    if test_cap.isOpened():
        print("[OK] Camera is accessible")
        test_cap.release()
    else:
        print("[WARNING] Camera may not be accessible")

    # Run main system
    main()